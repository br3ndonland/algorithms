# Python packaging

## Table of Contents <!-- omit in toc -->

- [Virtual environments and dependencies](#virtual-environments-and-dependencies)
  - [Pipenv](#pipenv)
  - [venv](#venv)
  - [virtualenv](#virtualenv)
- [Packaging](#packaging)
  - [flit](#flit)
  - [Poetry](#poetry)
  - [`setuptools`](#setuptools)
  - [tox](#tox)
- [Confusing configuration files](#confusing-configuration-files)
  - [Background](#background)
  - [`__init__.py`](#initpy)
  - [_config.py_](#configpy)
  - [_conftest.py_](#conftestpy)
  - [_pyproject.toml_](#pyprojecttoml)
  - [_setup.cfg_](#setupcfg)
  - [_setup.py_](#setuppy)
- [Talks](#talks)
  - [PyCon 2015: David Beazley](#pycon-2015-david-beazley)
  - [PyCon 2019: Russell Keith-Magee](#pycon-2019-russell-keith-magee)

## Virtual environments and dependencies

### Pipenv

- **[Pipenv](https://pipenv.readthedocs.io/en/latest/)** was previously used to manage the development virtual environment for this project.
- **The future of Pipenv is unclear.** It went all of 2019 without a major release, and has many bugs. Jacob Kaplan-Moss (Django co-creator) has commented on how "the lead of Pipenv was someone with a history of not treating his collaborators well," and on the "bugs and rapid API changes" of Pipenv. Many developers are switching to [Poetry](https://python-poetry.org).
  - [Jacob Kaplan-Moss | Blog 20191111: My Python development environment, 2020 edition](https://jacobian.org/2019/nov/11/python-environment-2020/)
  - [Telnyx | 20200124 Nick Timkovich: RIP Pipenv](https://medium.com/telnyx-engineering/rip-pipenv-tried-too-hard-do-what-you-need-with-pip-tools-d500edc161d4)

### venv

Python 3 is bundled with the [`venv` module](https://docs.python.org/3/tutorial/venv.html) for creation of virtual environments.

1. **Install and activate Python virtual environment**: The shell commands in the code block below will create a Python virtual environment, activate the virtual environment and display a modified virtual environment prompt
2. **Install required Python modules into the virtual environment**: Use `pip` to install required modules listed in _requirements.txt_. The modules will be installed locally within the virtual environment. The _requirements.txt_ file is generated by running `pip freeze > requirements.txt`.
3. **Start application**: Use the appropriate command to start your application within the virtual environment. For Flask, this is usually `python app.py` or `python -m flask run`.

```sh
~
❯ cd path/to/repo

# 1. install and activate virtual env
~/path/to/repo
❯ python3 -m venv venv

~/path/to/repo
❯ . venv/bin/activate

# 2. install modules
~/path/to/repo
(venv) path ❯ pip install -r requirements.txt

# 3. run app: the example below works for Flask
~/path/to/repo
(venv) path ❯ python app.py
```

### virtualenv

[Virtualenv](https://virtualenv.pypa.io/en/latest/) is similar to `venv`, but with additional features.

## Packaging

### flit

_TODO_

### Poetry

[Poetry](https://python-poetry.org/) is recommended for Python virtual environments, dependency management, and packaging.

#### Virtual environments

_TODO_

#### Dependency management

- To learn how to use semver syntax, check out the [npm semver calculator](https://semver.npmjs.com/).

#### Packaging

_TODO_

### `setuptools`

_TODO_

### tox

[Tox](https://pypi.org/project/tox/)

## Confusing configuration files

### Background

_TODO_: write up notes in actual sentences

I got interested in this topic during a Boston Python User Group Meetup event.

Repo: [br3ndonland/test3](https://github.com/br3ndonland/test3)

- Moved tests to tests directory, didn't run -> conftest.py
- Moved Python modules to separate directory, didn't run -> `__init__.py`
- setup.py: https://docs.pytest.org/en/latest/goodpractices.html, https://github.com/br3ndonland/test3/commit/aa68546fc08edd835e93dff6349914966fb67ec6

### `__init__.py`

_TODO_

See the [Python 3 docs tutorial on modules](https://docs.python.org/3/tutorial/modules.html), especially the [packages section](https://docs.python.org/3/tutorial/modules.html#packages):

> The `__init__.py` files are required to make Python treat directories containing the file as packages. This prevents directories with a common name, such as string, unintentionally hiding valid modules that occur later on the module search path. In the simplest case, `__init__.py` can just be an empty file, but it can also execute initialization code for the package or set the `__all__` variable, described later.

### _config.py_

_TODO_

### _conftest.py_

In many ways, _conftest.py_ is like _setup.py_ for pytest. It helps pytest understand your project structure so that pytest can find Python modules to test.

If your tests and modules are in separate directories and you don't have _conftest.py_, pytest may throw a `ModuleNotFoundError`. Pytest finds the tests, but the tests can't find the modules they `import` from the root directory. A solution, as explained on [Stack Overflow](https://stackoverflow.com/questions/10253826), is to simply create an empty _conftest.py_ file in the root directory. This seems strange to me.

### _pyproject.toml_

As explained in the README for the Black autoformatter, _pyproject.toml_ can replace _setup.cfg_ and _setup.py_.

### _setup.cfg_

_TODO_

### _setup.py_

The _setup.py_ [setup configuration file](https://docs.python.org/3/distutils/configfile.html) helps Python understand your project structure. It's mostly used by [`setuptools` ](https://setuptools.readthedocs.io/en/latest/setuptools.html) to distribute Python packages on [PyPI](https://pypi.org/).

For example, if your tests are in a sub-directory like _test/_, adding `setup.py` helps pytest locate Python modules to load when running tests.

To use the _setup.py_ file during local development, simply run `pip install -e .` as described in the [`pip install -e` docs](https://pip.pypa.io/en/stable/reference/pip_install/#editable-installs) and the [pytest docs on good integration practices](https://docs.pytest.org/en/latest/goodpractices.html).

Poetry projects don't need a separate _setup.py_ because it's managed automatically by Poetry. Attempting to use a separate _setup.py_ file with Poetry may result in errors, as described in [GitHub issue 1279](https://github.com/python-poetry/poetry/issues/1279).

## Talks

### PyCon 2015: David Beazley

[David Beazley](http://dabeaz.com/index.html) talk [Modules and Packages: Live and Let Die](https://youtu.be/bGYZEKstQuQ). See [slides](http://dabeaz.com/modulepackage/ModulePackage.pdf) and [GitHub repo](https://github.com/dabeaz/modulepackage).

- Intro
  - David's speaking cadence is choppy and sporadic, especially at higher speeds.
  - David opens with a Hieronymus Bosch painting, [The Garden of Earthly Delights](https://en.wikipedia.org/wiki/The_Garden_of_Earthly_Delights). I think it was appropriate for the madness in this presentation.
  - Slide 18: each module is isolated. what happens in a module stays in a module.
  - 22: generally try not to use `from module import *`. Also see slide 53: you can define `__all__` to control behavior of `from module import *` within `__init__.py`.
  - 25: file names lowercase, leading underscore for private
  - There's an import cache. Imports only happen once. Don't manually reload modules.
- [33](https://youtu.be/bGYZEKstQuQ?t=892) part 2: packages

  - It's easier to split up code into modules, but difficult to manage all the imports from those modules.
  - 37: modules are easy, packages are hard (introduce complexity).
  - [40](https://youtu.be/bGYZEKstQuQ?t=1189): explicit relative imports
  - 42: PEP 8 recommends absolute imports and discourages relative imports, but the Python standard library doesn't even follow that. It does permit explicit relative imports when useful.
  - [48](https://youtu.be/bGYZEKstQuQ?t=1431) `__init__.py`: "What are you supposed to do in those files?" Seriously. I like the idea of combining imports in the `__init__.py`.
  - _spam/`__init__.py`_
    ```py
    from .foo import Foo
    from .bar import Bar
    ```
  - Then in a module

    ```py
    import spam

    f = spam.Foo()
    b = spam.Bar()
    ```

  - Case study: the collections "module", which is actually a package.
  - 53: control exports with `__all__`
  - 60: `__init__` "connotes initialization, not implementation": don't simply put all your code into `__init__`.

- [64](https://youtu.be/bGYZEKstQuQ?t=2489): Part 3 - `__main__`

  - 67: `python3 -m pip` is useful, helps ensure the correct version of Python is used.
  - 68: `__main__.py` is an automatic entry point. If `__main__.py` is present, Python can execute the entire directory automatically with `python3 dirname`. Python can even do this for zip files. You can also prepend a Python shebang onto a zip archive, add `chmod +x`, and it will run. David admitted this blew his mind, even after many years of Python programming. See [PEP 441](https://www.python.org/dev/peps/pep-0441/).

    ```sh
    python3 -m zipfile -c spam.zip spam/*.py
    rm -rf spam
    python3 spam.zip
    ```

- [74](https://youtu.be/bGYZEKstQuQ?t=3104): Part 4 - `sys.path`
  - This is the "hell" part of the Hieronymus Bosch painting
  - "Amost every tricky problem concerning modules/packages is related to `sys.path`"
  - `sys.path` is a list of strings
  - 90: Path construction - _site.py_
  - [92](https://youtu.be/bGYZEKstQuQ?t=3922): venv and virtual environments
    - venv makes a new directory with a _pyvenv.cfg_ file and a fresh Python install
    - There are also `.pth` files. I've never interacted with these files.
  - 104: package managers (`easy_install`, pip, conda, etc) - "Do I want to discuss further? Nope."
- [105](https://youtu.be/bGYZEKstQuQ?t=4567): Part 5 - namespace packages
  - [106](https://youtu.be/bGYZEKstQuQ?t=4591): "Die `__init__.py` Die!"
    - You can omit `__init__.py`, but then you end up with a namespace package.
    - 1:24:30: "You sort of realize that you're entering, kind of, this world of madness."
  - 112: applications - namespace packages could be used for frameworks that want to allow user-customized plugin directories.
  - [113](https://youtu.be/bGYZEKstQuQ?t=5190): building a user-extensible framework called "Telly"
    - Plugins are added as sub-directories without separate `__init__.py` files
    - They do some `__path__` hacking in the top-level `__init__.py` to collect the plugins
    - **I don't like the approach of using namespace modules for user plugins. A better approach would be building plugins as Python packages.** Packages can then be added to the dependency list in _requirements.txt_ or _pyproject.toml_, and imported in the standard way when needed.
    - It's easiest and most reproducible to work with Python's standard library module and import system. **The problem is, while it's easier to _work with_ Python modules as packages, it's complicated to _produce_ the packages. This is why user-friendly packaging tools like Poetry are important.** If we make it easier to turn Python code into packages, we solve many problems.
- [122](https://youtu.be/bGYZEKstQuQ?t=5848): Part 6 - the module

  - We're getting into the "crazy hacks part of the tutorial"
  - The `import` statement opens and executes a Python file
  - 129: _.pyc_ Pycache files are compiled Python bytecode. Examining compiled Python bytecode:

    ```py
    c = compile(code, "blah.py", "exec")
    import dis
    dis.dis(c)
    ```

- [154](https://youtu.be/bGYZEKstQuQ?t=7668): Part 7 - the module reloaded
- [168](https://youtu.be/bGYZEKstQuQ?t=8210): Part 8 - import hooks
  - There's some more info here about `sys.path` and `sys.meta_path`.
  - The `ModuleSpec` contains information about how to load the module.
  - 183: "Modern module loading technique is better." Duh.
  - 184: David proposes the idea of lazy imports, in which modules are executed when they are needed instead of right away
- [199](https://youtu.be/bGYZEKstQuQ?t=9960): Part 9 - path hooks
  - Revisiting `sys.path` yet again
  - `sys.path_hooks` is an object that helps locate modules
  - Example: importing from URLs
- Final comments
  - "A good policy: Keep it as simple as possible"
  - "It's good to understand what's possible... In case you have to debug it"
  - David teaches Python classes in Chicago

### PyCon 2019: Russell Keith-Magee

[PyCon 2019 keynote: Russell Keith-Magee](https://youtu.be/ftP5BQh1-YM?t=2033)

- Found via the [Python Bytes podcast episode 138](https://pythonbytes.fm/episodes/show/138/will-pyoxidizer-weld-shut-one-of-python-s-major-gaps) 2019-07-08
